<!--
This HTML file is designed to visualize vector database benchmark results using Chart.js and Tailwind CSS.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Database Benchmark Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.1/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        .chart-container {
            position: relative;
            height: 500px;
            width: 100%;
        }

        .file-input {
            background: linear-gradient(145deg, #f3f4f6, #e5e7eb);
        }

        .animate-pulse-custom {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="max-w-7xl mx-auto p-6 bg-white min-h-screen">
        <!-- Header -->
        <div class="mb-8">
            <h1 class="text-3xl font-bold text-gray-900 mb-2">Vector Database Benchmark Visualization</h1>
            <p class="text-gray-600">Upload your JSON benchmark data to create interactive performance charts comparing different engines and configurations.</p>

            <!-- Info about Pareto filtering -->
            <div class="mt-4 p-3 bg-green-100 border-2 border-green-400 rounded">
                <div style="font-size: 16px; font-weight: bold; color: #059669;">
                    üéØ Pareto Frontier Filter Applied
                </div>
                <div style="font-size: 14px; margin-top: 6px; color: #047857;">
                    Shows only datapoints that improve performance within each parallel thread group
                </div>
            </div>
        </div>

        <!-- Data Input Section -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
            <div class="space-y-4">
                <h2 class="text-xl font-semibold text-gray-800">Data Input</h2>

                <!-- File 1 Input -->
                <div class="p-4 border border-blue-200 rounded-lg bg-blue-50">
                    <h3 class="text-sm font-semibold text-blue-800 mb-2">Primary Dataset</h3>
                    <div class="space-y-3">
                        <div>
                            <label class="block text-xs font-medium text-blue-700 mb-1">Dataset Label/Version</label>
                            <input
                                type="text"
                                id="primaryLabel"
                                placeholder="e.g., v1.0, Before optimization, Current"
                                class="w-full p-2 border border-blue-300 rounded text-xs focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                value="Primary"
                            />
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-blue-700 mb-1">Upload JSON File</label>
                            <input
                                type="file"
                                id="fileInput"
                                accept=".json"
                                class="block w-full text-xs text-gray-500 file:mr-4 file:py-1 file:px-3 file:rounded file:border-0 file:text-xs file:font-semibold file:bg-blue-100 file:text-blue-700 hover:file:bg-blue-200"
                            />
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-blue-700 mb-1">Or Paste JSON Data</label>
                            <textarea
                                id="jsonInput"
                                placeholder="Paste your JSON benchmark data here..."
                                class="w-full h-20 p-2 border border-blue-300 rounded text-xs focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                            ></textarea>
                        </div>
                        <div class="flex space-x-2">
                            <button
                                id="loadDataBtn"
                                class="px-3 py-1 bg-blue-600 text-white rounded text-xs hover:bg-blue-700 focus:ring-2 focus:ring-blue-500 transition-colors duration-200"
                            >
                                Load Primary
                            </button>
                            <button
                                id="loadSampleBtn"
                                class="px-3 py-1 bg-green-600 text-white rounded text-xs hover:bg-green-700 focus:ring-2 focus:ring-green-500 transition-colors duration-200"
                            >
                                Load Sample
                            </button>
                        </div>
                    </div>
                </div>

                <!-- File 2 Input -->
                <div class="p-4 border border-orange-200 rounded-lg bg-orange-50">
                    <h3 class="text-sm font-semibold text-orange-800 mb-2">Comparison Dataset (Optional)</h3>
                    <div class="space-y-3">
                        <div>
                            <label class="block text-xs font-medium text-orange-700 mb-1">Dataset Label/Version</label>
                            <input
                                type="text"
                                id="comparisonLabel"
                                placeholder="e.g., v2.0, After optimization, New"
                                class="w-full p-2 border border-orange-300 rounded text-xs focus:ring-2 focus:ring-orange-500 focus:border-transparent"
                                value="Comparison"
                            />
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-orange-700 mb-1">Upload JSON File</label>
                            <input
                                type="file"
                                id="fileInput2"
                                accept=".json"
                                class="block w-full text-xs text-gray-500 file:mr-4 file:py-1 file:px-3 file:rounded file:border-0 file:text-xs file:font-semibold file:bg-orange-100 file:text-orange-700 hover:file:bg-orange-200"
                            />
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-orange-700 mb-1">Or Paste JSON Data</label>
                            <textarea
                                id="jsonInput2"
                                placeholder="Paste comparison data here..."
                                class="w-full h-20 p-2 border border-orange-300 rounded text-xs focus:ring-2 focus:ring-orange-500 focus:border-transparent resize-none"
                            ></textarea>
                        </div>
                        <div class="flex space-x-2">
                            <button
                                id="loadData2Btn"
                                class="px-3 py-1 bg-orange-600 text-white rounded text-xs hover:bg-orange-700 focus:ring-2 focus:ring-orange-500 transition-colors duration-200"
                            >
                                Load Comparison
                            </button>
                            <button
                                id="clearData2Btn"
                                class="px-3 py-1 bg-gray-600 text-white rounded text-xs hover:bg-gray-700 focus:ring-2 focus:ring-gray-500 transition-colors duration-200"
                            >
                                Clear
                            </button>
                        </div>
                    </div>
                </div>

                <div id="errorMessage" class="hidden p-3 bg-red-50 border border-red-200 rounded-lg text-red-700"></div>
                <div id="successMessage" class="hidden p-3 bg-green-50 border border-green-200 rounded-lg text-green-700"></div>
            </div>

            <div class="space-y-4">
                <h2 class="text-xl font-semibold text-gray-800">Expected Data Format</h2>
                <div class="p-4 bg-gray-50 rounded-lg text-sm border">
                    <pre class="whitespace-pre-wrap text-gray-700 text-xs">[
  {
    "engine_name": "qdrant",
    "setup_name": "qdrant-rps-m-16-ef-128",
    "dataset_name": "dbpedia-openai-1M-1536-angular",
    "rps": 394.08,
    "mean_time": 0.247,
    "p95_time": 0.260,
    "p99_time": 0.267,
    "mean_precisions": 0.9975,
    "parallel": 100,
    "upload_time": 110.66,
    "engine_params": {
      "hnsw_config": {
        "m": 16,
        "ef_construct": 128
      },
      "hnsw_ef": 512
    }
  },
  ...
]</pre>
                </div>
                <p class="text-sm text-gray-600">
                    Array of benchmark result objects with engine names, performance metrics, and precision values.
                </p>
            </div>
        </div>

        <!-- Data Summary -->
        <div id="dataSummary" class="hidden mb-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
            <h3 class="font-semibold text-blue-800 mb-2">Data Summary:</h3>
            <div id="primarySummary" class="mb-2">
                <h4 class="font-medium text-blue-700 text-sm"><span id="primarySummaryLabel">Primary</span> Dataset:</h4>
                <div class="text-xs text-blue-600 ml-4 mb-1">
                    <strong>File:</strong> <span id="primaryFilename">sample-data</span>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-xs text-blue-600 ml-4">
                    <div><strong>Engines:</strong> <span id="engineCount">0</span></div>
                    <div><strong>Datasets:</strong> <span id="datasetCount">0</span></div>
                    <div><strong>Records:</strong> <span id="recordCount">0</span></div>
                </div>
            </div>
            <div id="comparisonSummary" class="hidden">
                <h4 class="font-medium text-orange-700 text-sm"><span id="comparisonSummaryLabel">Comparison</span> Dataset:</h4>
                <div class="text-xs text-orange-600 ml-4 mb-1">
                    <strong>File:</strong> <span id="comparisonFilename">-</span>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-xs text-orange-600 ml-4">
                    <div><strong>Engines:</strong> <span id="engineCount2">0</span></div>
                    <div><strong>Datasets:</strong> <span id="datasetCount2">0</span></div>
                    <div><strong>Records:</strong> <span id="recordCount2">0</span></div>
                </div>
            </div>
        </div>

        <!-- Chart Controls -->
        <div class="mb-6 p-4 bg-gray-50 rounded-lg border">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Y-Axis Metric</label>
                    <select
                        id="yMetricSelect"
                        class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                    >
                        <option value="rps">RPS (Requests Per Second)</option>
                        <option value="mean_time">Mean Latency (ms)</option>
                        <option value="p95_time">P95 Latency (ms)</option>
                        <option value="p99_time">P99 Latency (ms)</option>
                        <option value="upload_time">Upload Time (s)</option>
                        <option value="total_upload_time">Index Time (s)</option>
                    </select>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">X-Axis</label>
                    <select
                        id="xAxisSelect"
                        class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                    >
                        <option value="mean_precisions">Precision</option>
                        <option value="parallel">Parallel Threads</option>
                        <option value="setup_name">Setup Name</option>
                    </select>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Group By</label>
                    <select
                        id="groupBySelect"
                        class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                    >
                        <option value="engine_name">Engine</option>
                        <option value="dataset_name">Dataset</option>
                        <option value="setup_name">Setup</option>
                        <option value="none">No Grouping</option>
                    </select>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Chart Type</label>
                    <select
                        id="chartTypeSelect"
                        class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                    >
                        <option value="line">Line Chart</option>
                        <option value="scatter">Scatter Plot</option>
                        <option value="bar">Bar Chart</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Filters -->
        <div id="filtersSection" class="hidden mb-6 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
            <h3 class="font-semibold text-yellow-800 mb-3">Filters</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4" id="filterControls">
                <!-- Dynamic filter controls will be added here -->
            </div>
        </div>

        <!-- Chart -->
        <div class="bg-white border border-gray-200 rounded-lg p-6 shadow-sm">
            <div class="flex justify-between items-center mb-4">
                <h2 id="chartTitle" class="text-xl font-semibold text-gray-800">
                    Performance Chart
                </h2>
                <div class="flex items-center gap-4">
                    <span class="text-sm text-gray-600">üîç Scroll to zoom ‚Ä¢ Drag to select area ‚Ä¢ Alt+Drag to pan</span>
                    <button
                        id="resetZoomBtn"
                        class="px-3 py-1 bg-gray-500 text-white rounded text-xs hover:bg-gray-600 focus:ring-2 focus:ring-gray-400 transition-colors duration-200"
                    >
                        Reset Zoom
                    </button>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="benchmarkChart"></canvas>
            </div>
        </div>

    </div>

    <script>
        // Sample data matching the user's format
        const sampleData = [
            {
                "engine_name": "qdrant",
                "setup_name": "qdrant-rps-m-16-ef-128",
                "dataset_name": "dbpedia-openai-1M-1536-angular",
                "search_idx": "0",
                "upload_time": 118.20,
                "total_upload_time": 318.64,
                "p95_time": 0.007691,
                "rps": 130.26,
                "parallel": 1,
                "p99_time": 0.008957,
                "mean_time": 0.006716,
                "mean_precisions": 0.9784,
                "engine_params": {
                    "hnsw_config": {
                        "m": 16,
                        "ef_construct": 128
                    },
                    "hnsw_ef": 64
                }
            },
            {
                "engine_name": "qdrant",
                "setup_name": "qdrant-rps-m-16-ef-128",
                "dataset_name": "dbpedia-openai-1M-1536-angular",
                "search_idx": "1",
                "upload_time": 118.20,
                "total_upload_time": 318.64,
                "p95_time": 0.009744,
                "rps": 112.17,
                "parallel": 1,
                "p99_time": 0.011519,
                "mean_time": 0.007994,
                "mean_precisions": 0.9901,
                "engine_params": {
                    "hnsw_config": {
                        "m": 16,
                        "ef_construct": 128
                    },
                    "hnsw_ef": 128
                }
            },
            {
                "engine_name": "qdrant",
                "setup_name": "qdrant-rps-m-16-ef-128",
                "dataset_name": "dbpedia-openai-1M-1536-angular",
                "search_idx": "2",
                "upload_time": 118.20,
                "total_upload_time": 318.64,
                "p95_time": 0.012000,
                "rps": 92.79,
                "parallel": 1,
                "p99_time": 0.015120,
                "mean_time": 0.009842,
                "mean_precisions": 0.9950,
                "engine_params": {
                    "hnsw_config": {
                        "m": 16,
                        "ef_construct": 128
                    },
                    "hnsw_ef": 256
                }
            },
            {
                "engine_name": "qdrant",
                "setup_name": "qdrant-rps-m-16-ef-128",
                "dataset_name": "dbpedia-openai-1M-1536-angular",
                "search_idx": "4",
                "upload_time": 118.20,
                "total_upload_time": 318.64,
                "p95_time": 0.016229,
                "rps": 808.74,
                "parallel": 100,
                "p99_time": 0.026924,
                "mean_time": 0.009566,
                "mean_precisions": 0.9784,
                "engine_params": {
                    "hnsw_config": {
                        "m": 16,
                        "ef_construct": 128
                    },
                    "hnsw_ef": 64
                }
            },
            {
                "engine_name": "qdrant",
                "setup_name": "qdrant-rps-m-16-ef-128",
                "dataset_name": "dbpedia-openai-1M-1536-angular",
                "search_idx": "5",
                "upload_time": 118.20,
                "total_upload_time": 318.64,
                "p95_time": 0.079736,
                "rps": 823.07,
                "parallel": 100,
                "p99_time": 0.114752,
                "mean_time": 0.033456,
                "mean_precisions": 0.9901,
                "engine_params": {
                    "hnsw_config": {
                        "m": 16,
                        "ef_construct": 128
                    },
                    "hnsw_ef": 128
                }
            }
        ];

        // Color palettes for different datasets
        const primaryColors = [
            '#1E40AF', '#2563EB', '#3B82F6', '#60A5FA', '#93C5FD',
            '#1E3A8A', '#1D4ED8', '#2D7AE6', '#4F9AF2', '#7CB3F7'
        ];

        const comparisonColors = [
            '#EA580C', '#F97316', '#FB923C', '#FDBA74', '#FED7AA',
            '#C2410C', '#DC2626', '#EF4444', '#F87171', '#FCA5A5'
        ];

        // Legacy colors array for single dataset mode
        const colors = primaryColors;

        // Utility function to get filename without extension
        function getFilenameWithoutExtension(filename) {
            if (!filename) return '';
            const lastDotIndex = filename.lastIndexOf('.');
            if (lastDotIndex === -1) return filename;
            return filename.substring(0, lastDotIndex);
        }

        // State
        let primaryData = [];
        let comparisonData = [];
        let currentData = [];
        let filteredData = [];
        let chart = null;
        let filters = {};
        let isComparisonMode = false;
        let primaryFilename = '';
        let comparisonFilename = '';

        // DOM elements
        const fileInput = document.getElementById('fileInput');
        const fileInput2 = document.getElementById('fileInput2');
        const jsonInput = document.getElementById('jsonInput');
        const jsonInput2 = document.getElementById('jsonInput2');
        const primaryLabel = document.getElementById('primaryLabel');
        const comparisonLabel = document.getElementById('comparisonLabel');
        const loadDataBtn = document.getElementById('loadDataBtn');
        const loadData2Btn = document.getElementById('loadData2Btn');
        const clearData2Btn = document.getElementById('clearData2Btn');
        const loadSampleBtn = document.getElementById('loadSampleBtn');
        const errorMessage = document.getElementById('errorMessage');
        const successMessage = document.getElementById('successMessage');
        const yMetricSelect = document.getElementById('yMetricSelect');
        const xAxisSelect = document.getElementById('xAxisSelect');
        const groupBySelect = document.getElementById('groupBySelect');
        const chartTypeSelect = document.getElementById('chartTypeSelect');
        const chartTitle = document.getElementById('chartTitle');
        const dataSummary = document.getElementById('dataSummary');
        const primarySummary = document.getElementById('primarySummary');
        const comparisonSummary = document.getElementById('comparisonSummary');
        const filtersSection = document.getElementById('filtersSection');
        const filterControls = document.getElementById('filterControls');
        const resetZoomBtn = document.getElementById('resetZoomBtn');

        // Initialize with sample data
        primaryFilename = 'sample-data.json';
        loadPrimaryData(sampleData);

        // Pareto frontier filtering function
        function applyParetoFilter(data, yMetric) {
            // Always apply Pareto filter for all metrics
            if (data.length === 0) {
                return data;
            }

            console.log(`DEBUG PARETO: Input data length: ${data.length}, yMetric: ${yMetric}`);
            console.log(`DEBUG PARETO: First few points:`, data.slice(0, 3).map(p => ({
                precision: p.mean_precisions, 
                rps: p.rps, 
                parallel: p.parallel,
                fileSource: p.fileSource
            })));

            // Group data by parallel thread count
            const parallelGroups = {};
            data.forEach(point => {
                const parallel = point.parallel;
                if (!parallelGroups[parallel]) {
                    parallelGroups[parallel] = [];
                }
                parallelGroups[parallel].push(point);
            });

            console.log(`DEBUG PARETO: Parallel groups:`, Object.keys(parallelGroups).map(k => `${k}: ${parallelGroups[k].length} points`));

            const allFiltered = [];

            // Apply Pareto filter to each parallel group separately
            Object.keys(parallelGroups).forEach(parallel => {
                const groupData = parallelGroups[parallel];
                
                // Sort by precision descending (highest first) within this group
                const sortedByPrecision = [...groupData].sort((a, b) => b.mean_precisions - a.mean_precisions);

                if (sortedByPrecision.length === 0) return;

                const filtered = [];
                
                // Determine if higher or lower values are better for this metric
                const isHigherBetter = yMetric === 'rps';
                
                // Start with the highest precision point
                let bestPerformance = sortedByPrecision[0][yMetric];
                if (bestPerformance === null || bestPerformance === undefined) {
                    return; // Skip this group if no valid metric data
                }
                filtered.push(sortedByPrecision[0]);

                // For each subsequent point (lower precision), only include if it improves performance
                for (let i = 1; i < sortedByPrecision.length; i++) {
                    const currentValue = sortedByPrecision[i][yMetric];
                    if (currentValue === null || currentValue === undefined) {
                        continue; // Skip points with missing data
                    }
                    
                    const isImprovement = isHigherBetter ?
                        currentValue > bestPerformance :
                        currentValue < bestPerformance;

                    if (isImprovement) {
                        filtered.push(sortedByPrecision[i]);
                        bestPerformance = currentValue; // Update the best performance threshold
                    }
                }

                allFiltered.push(...filtered);
            });

            return allFiltered;
        }

        // Event listeners
        fileInput.addEventListener('change', handleFileUpload);
        fileInput2.addEventListener('change', handleFile2Upload);
        loadDataBtn.addEventListener('click', handleJsonInput);
        loadData2Btn.addEventListener('click', handleJson2Input);
        clearData2Btn.addEventListener('click', clearComparisonData);
        loadSampleBtn.addEventListener('click', () => {
            primaryFilename = 'sample-data.json';
            loadPrimaryData(sampleData);
        });
        primaryLabel.addEventListener('input', updateChart);
        comparisonLabel.addEventListener('input', updateChart);
        yMetricSelect.addEventListener('change', updateChart);
        xAxisSelect.addEventListener('change', updateChart);
        groupBySelect.addEventListener('change', updateChart);
        chartTypeSelect.addEventListener('change', updateChart);
        resetZoomBtn.addEventListener('click', () => {
            if (chart) {
                chart.resetZoom();
            }
        });

        function showMessage(element, message, isError = false) {
            element.textContent = message;
            element.className = `p-3 border rounded-lg ${isError ? 'bg-red-50 border-red-200 text-red-700' : 'bg-green-50 border-green-200 text-green-700'}`;
            element.classList.remove('hidden');

            const otherMessage = isError ? successMessage : errorMessage;
            otherMessage.classList.add('hidden');

            setTimeout(() => {
                element.classList.add('hidden');
            }, 5000);
        }

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                try {
                    const text = await file.text();
                    const parsedData = JSON.parse(text);
                    if (Array.isArray(parsedData)) {
                        primaryFilename = file.name;
                        loadPrimaryData(parsedData);
                        jsonInput.value = JSON.stringify(parsedData, null, 2);
                        showMessage(successMessage, `Primary file "${file.name}" loaded successfully!`);
                    } else {
                        throw new Error('Data should be an array of objects');
                    }
                } catch (err) {
                    showMessage(errorMessage, 'Error reading file or invalid JSON format.', true);
                }
            }
        }

        async function handleFile2Upload(event) {
            const file = event.target.files[0];
            if (file) {
                try {
                    const text = await file.text();
                    const parsedData = JSON.parse(text);
                    if (Array.isArray(parsedData)) {
                        comparisonFilename = file.name;
                        loadComparisonData(parsedData);
                        jsonInput2.value = JSON.stringify(parsedData, null, 2);
                        showMessage(successMessage, `Comparison file "${file.name}" loaded successfully!`);
                    } else {
                        throw new Error('Data should be an array of objects');
                    }
                } catch (err) {
                    showMessage(errorMessage, 'Error reading comparison file or invalid JSON format.', true);
                }
            }
        }

        function handleJsonInput() {
            try {
                const parsedData = JSON.parse(jsonInput.value);
                if (Array.isArray(parsedData)) {
                    primaryFilename = 'pasted-data.json';
                    loadPrimaryData(parsedData);
                    showMessage(successMessage, 'Primary JSON data loaded successfully!');
                } else {
                    throw new Error('Data should be an array of objects');
                }
            } catch (err) {
                showMessage(errorMessage, 'Invalid JSON format. Please check your data structure.', true);
            }
        }

        function handleJson2Input() {
            try {
                const parsedData = JSON.parse(jsonInput2.value);
                if (Array.isArray(parsedData)) {
                    comparisonFilename = 'pasted-data-2.json';
                    loadComparisonData(parsedData);
                    showMessage(successMessage, 'Comparison JSON data loaded successfully!');
                } else {
                    throw new Error('Data should be an array of objects');
                }
            } catch (err) {
                showMessage(errorMessage, 'Invalid comparison JSON format. Please check your data structure.', true);
            }
        }

        function loadPrimaryData(data) {
            primaryData = data.map(row => ({
                ...row,
                fileSource: 'primary',
                filename: primaryFilename
            }));
            combineDatasets();
        }

        function loadComparisonData(data) {
            comparisonData = data.map(row => ({
                ...row,
                fileSource: 'comparison',
                filename: comparisonFilename
            }));
            isComparisonMode = true;
            comparisonSummary.classList.remove('hidden');
            console.log(`DEBUG: loadComparisonData - Set isComparisonMode to true, comparisonData.length: ${comparisonData.length}`);
            combineDatasets();
        }

        function clearComparisonData() {
            comparisonData = [];
            comparisonFilename = '';
            isComparisonMode = false;
            comparisonSummary.classList.add('hidden');
            jsonInput2.value = '';
            fileInput2.value = '';
            combineDatasets();
            showMessage(successMessage, 'Comparison data cleared!');
        }

        function combineDatasets() {
            currentData = [...primaryData, ...comparisonData];
            filteredData = [...currentData];
            updateDataSummary();
            createFilterControls();
            updateChart();
        }

        function loadData(data) {
            // Legacy function for backward compatibility
            loadPrimaryData(data);
        }

        function updateDataSummary() {
            // Primary dataset summary
            const engines1 = new Set(primaryData.map(d => d.engine_name));
            const datasets1 = new Set(primaryData.map(d => d.dataset_name));

            document.getElementById('engineCount').textContent = engines1.size;
            document.getElementById('datasetCount').textContent = datasets1.size;
            document.getElementById('recordCount').textContent = primaryData.length;
            document.getElementById('primaryFilename').textContent = primaryFilename || 'sample-data';

            // Comparison dataset summary
            if (isComparisonMode && comparisonData.length > 0) {
                const engines2 = new Set(comparisonData.map(d => d.engine_name));
                const datasets2 = new Set(comparisonData.map(d => d.dataset_name));

                document.getElementById('engineCount2').textContent = engines2.size;
                document.getElementById('datasetCount2').textContent = datasets2.size;
                document.getElementById('recordCount2').textContent = comparisonData.length;
                document.getElementById('comparisonFilename').textContent = comparisonFilename || '-';
            }

            dataSummary.classList.remove('hidden');
        }

        function createFilterControls() {
            const filterFields = ['engine_name', 'dataset_name', 'setup_name', 'parallel'];
            filterControls.innerHTML = '';
            filters = {};

            filterFields.forEach(field => {
                const values = [...new Set(currentData.map(d => d[field]))].sort((a, b) => {
                    // Sort numerically for parallel field
                    if (field === 'parallel') {
                        return Number(a) - Number(b);
                    }
                    return String(a).localeCompare(String(b));
                });
                if (values.length > 1) {
                    const div = document.createElement('div');
                    const fieldLabel = field === 'parallel' ? 'PARALLEL THREADS' : field.replace('_', ' ').toUpperCase();
                    
                    // Set default value for parallel field to 100
                    const defaultValue = field === 'parallel' && values.includes(100) ? '100' : '';
                    
                    div.innerHTML = `
                        <label class="block text-sm font-medium text-yellow-700 mb-2">${fieldLabel}</label>
                        <select id="filter_${field}" class="w-full p-2 border border-yellow-300 rounded-lg focus:ring-2 focus:ring-yellow-500 text-sm">
                            <option value="">All</option>
                            ${values.map(v => `<option value="${v}" ${v == defaultValue ? 'selected' : ''}>${field === 'parallel' ? v + ' threads' : v}</option>`).join('')}
                        </select>
                    `;
                    filterControls.appendChild(div);

                    // Set initial filter value
                    if (defaultValue) {
                        filters[field] = defaultValue;
                    }

                    document.getElementById(`filter_${field}`).addEventListener('change', (e) => {
                        filters[field] = e.target.value;
                        applyFilters();
                    });
                }
            });

            if (filterControls.children.length > 0 || currentData.length > 0) {
                filtersSection.classList.remove('hidden');
            }
            
            // Apply initial filters
            applyFilters();
        }

        function applyFilters() {
            filteredData = currentData.filter(row => {
                return Object.entries(filters).every(([field, value]) => {
                    if (!value) return true;

                    // Handle numeric comparison for parallel field
                    if (field === 'parallel') {
                        return Number(row[field]) === Number(value);
                    }

                    // String comparison for other fields
                    return row[field] === value;
                });
            });
            updateChart();
        }

        function getChartConfig() {
            const yMetric = yMetricSelect.value;
            const xAxis = xAxisSelect.value;
            const groupBy = groupBySelect.value;
            const chartType = chartTypeSelect.value;

            console.log(`DEBUG: getChartConfig called - isComparisonMode: ${isComparisonMode}, comparisonData.length: ${comparisonData.length}, groupBy: ${groupBy}`);

            let datasets = [];

            // Helper function to sort data by x-axis value
            function sortDataByXAxis(data) {
                return data.sort((a, b) => {
                    const aValue = xAxis === 'mean_precisions' ? a[xAxis] * 100 : a[xAxis];
                    const bValue = xAxis === 'mean_precisions' ? b[xAxis] * 100 : b[xAxis];

                    // Handle numeric vs string sorting
                    if (typeof aValue === 'number' && typeof bValue === 'number') {
                        return aValue - bValue;
                    } else {
                        return String(aValue).localeCompare(String(bValue));
                    }
                });
            }

            if (isComparisonMode && comparisonData.length > 0) {
                // Comparison mode: group by file source and then by the selected groupBy field
                const primaryFilenameShort = getFilenameWithoutExtension(primaryFilename);
                const comparisonFilenameShort = getFilenameWithoutExtension(comparisonFilename);

                if (groupBy === 'none') {
                    // Just separate by file source
                    let primaryDataFiltered = filteredData.filter(row => row.fileSource === 'primary');
                    let comparisonDataFiltered = filteredData.filter(row => row.fileSource === 'comparison');

                    console.log(`DEBUG: Before Pareto - Primary: ${primaryDataFiltered.length}, Comparison: ${comparisonDataFiltered.length}`);

                    // Apply Pareto filtering if enabled
                    primaryDataFiltered = applyParetoFilter(primaryDataFiltered, yMetric);
                    comparisonDataFiltered = applyParetoFilter(comparisonDataFiltered, yMetric);

                    console.log(`DEBUG: After Pareto - Primary: ${primaryDataFiltered.length}, Comparison: ${comparisonDataFiltered.length}`);
                    
                    // Check if we have the A-B-C pattern in the filtered results
                    console.log(`DEBUG: Checking primary data for A-B-C pattern...`);
                    const primarySorted = primaryDataFiltered.sort((a, b) => b.mean_precisions - a.mean_precisions);
                    const primaryRPS = primarySorted.map(p => p.rps);
                    for (let i = 0; i < primaryRPS.length - 2; i++) {
                        if (primaryRPS[i+1] < primaryRPS[i] && primaryRPS[i+2] > primaryRPS[i+1]) {
                            console.log(`‚ùå BUG DETECTED in PRIMARY at positions ${i}-${i+1}-${i+2}: RPS sequence: ${primaryRPS[i].toFixed(2)} -> ${primaryRPS[i+1].toFixed(2)} -> ${primaryRPS[i+2].toFixed(2)}`);
                            console.log(`   Setups: ${primarySorted[i].setup_name} -> ${primarySorted[i+1].setup_name} -> ${primarySorted[i+2].setup_name}`);
                            console.log(`   Parallel: ${primarySorted[i].parallel} -> ${primarySorted[i+1].parallel} -> ${primarySorted[i+2].parallel}`);
                        }
                    }
                    
                    console.log(`DEBUG: Checking comparison data for A-B-C pattern...`);
                    const comparisonSorted = comparisonDataFiltered.sort((a, b) => b.mean_precisions - a.mean_precisions);
                    const comparisonRPS = comparisonSorted.map(p => p.rps);
                    for (let i = 0; i < comparisonRPS.length - 2; i++) {
                        if (comparisonRPS[i+1] < comparisonRPS[i] && comparisonRPS[i+2] > comparisonRPS[i+1]) {
                            console.log(`‚ùå BUG DETECTED in COMPARISON at positions ${i}-${i+1}-${i+2}: RPS sequence: ${comparisonRPS[i].toFixed(2)} -> ${comparisonRPS[i+1].toFixed(2)} -> ${comparisonRPS[i+2].toFixed(2)}`);
                            console.log(`   Setups: ${comparisonSorted[i].setup_name} -> ${comparisonSorted[i+1].setup_name} -> ${comparisonSorted[i+2].setup_name}`);
                            console.log(`   Parallel: ${comparisonSorted[i].parallel} -> ${comparisonSorted[i+1].parallel} -> ${comparisonSorted[i+2].parallel}`);
                        }
                    }

                    // Then sort by X-axis
                    const primaryDataSorted = sortDataByXAxis(primaryDataFiltered);
                    const comparisonDataSorted = sortDataByXAxis(comparisonDataFiltered);

                    console.log(`DEBUG: Primary sorted precision range:`, 
                        primaryDataSorted.map(p => p.mean_precisions).slice(0, 3),
                        '...',
                        primaryDataSorted.map(p => p.mean_precisions).slice(-3)
                    );
                    console.log(`DEBUG: Comparison sorted precision range:`, 
                        comparisonDataSorted.map(p => p.mean_precisions).slice(0, 3),
                        '...',
                        comparisonDataSorted.map(p => p.mean_precisions).slice(-3)
                    );
                    
                    console.log(`DEBUG: Primary sorted RPS range:`, 
                        primaryDataSorted.map(p => p.rps).slice(0, 3),
                        '...',
                        primaryDataSorted.map(p => p.rps).slice(-3)
                    );
                    console.log(`DEBUG: Comparison sorted RPS range:`, 
                        comparisonDataSorted.map(p => p.rps).slice(0, 3),
                        '...',
                        comparisonDataSorted.map(p => p.rps).slice(-3)
                    );

                    datasets = [
                        {
                            label: primaryFilenameShort,
                            data: primaryDataSorted.map(row => ({
                                x: xAxis === 'mean_precisions' ? row[xAxis] * 100 : row[xAxis],
                                y: yMetric.includes('time') && yMetric !== 'total_upload_time' ? row[yMetric] * 1000 : row[yMetric],
                                originalData: row
                            })),
                            borderColor: primaryColors[0],
                            backgroundColor: primaryColors[0] + '20',
                            borderWidth: chartType === 'line' ? 3 : 1,
                            fill: false,
                            tension: 0.4,
                            pointRadius: chartType === 'scatter' ? 6 : 4,
                            pointStyle: 'circle'
                        },
                        {
                            label: comparisonFilenameShort,
                            data: comparisonDataSorted.map(row => ({
                                x: xAxis === 'mean_precisions' ? row[xAxis] * 100 : row[xAxis],
                                y: yMetric.includes('time') && yMetric !== 'total_upload_time' ? row[yMetric] * 1000 : row[yMetric],
                                originalData: row
                            })),
                            borderColor: comparisonColors[0],
                            backgroundColor: comparisonColors[0] + '20',
                            borderWidth: chartType === 'line' ? 3 : 1,
                            fill: false,
                            tension: 0.4,
                            pointRadius: chartType === 'scatter' ? 6 : 4,
                            pointStyle: 'triangle'
                        }
                    ];
                } else {
                    // Group by the selected field within each file source
                    const primaryGroups = [...new Set(filteredData.filter(d => d.fileSource === 'primary').map(d => d[groupBy]))];
                    const comparisonGroups = [...new Set(filteredData.filter(d => d.fileSource === 'comparison').map(d => d[groupBy]))];

                    // Primary dataset groups
                    primaryGroups.forEach((group, index) => {
                        let groupData = filteredData.filter(d => d.fileSource === 'primary' && d[groupBy] === group);
                        groupData = applyParetoFilter(groupData, yMetric);
                        groupData = sortDataByXAxis(groupData);

                        datasets.push({
                            label: `${primaryFilenameShort}: ${group}`,
                            data: groupData.map(row => ({
                                x: xAxis === 'mean_precisions' ? row[xAxis] * 100 : row[xAxis],
                                y: yMetric.includes('time') && yMetric !== 'total_upload_time' ? row[yMetric] * 1000 : row[yMetric],
                                originalData: row
                            })),
                            borderColor: primaryColors[index % primaryColors.length],
                            backgroundColor: primaryColors[index % primaryColors.length] + '20',
                            borderWidth: chartType === 'line' ? 3 : 1,
                            fill: false,
                            tension: 0.4,
                            pointRadius: chartType === 'scatter' ? 6 : 4,
                            pointStyle: 'circle'
                        });
                    });

                    // Comparison dataset groups
                    comparisonGroups.forEach((group, index) => {
                        let groupData = filteredData.filter(d => d.fileSource === 'comparison' && d[groupBy] === group);
                        groupData = applyParetoFilter(groupData, yMetric);
                        groupData = sortDataByXAxis(groupData);

                        datasets.push({
                            label: `${comparisonFilenameShort}: ${group}`,
                            data: groupData.map(row => ({
                                x: xAxis === 'mean_precisions' ? row[xAxis] * 100 : row[xAxis],
                                y: yMetric.includes('time') && yMetric !== 'total_upload_time' ? row[yMetric] * 1000 : row[yMetric],
                                originalData: row
                            })),
                            borderColor: comparisonColors[index % comparisonColors.length],
                            backgroundColor: comparisonColors[index % comparisonColors.length] + '20',
                            borderWidth: chartType === 'line' ? 3 : 1,
                            fill: false,
                            tension: 0.4,
                            pointRadius: chartType === 'scatter' ? 6 : 4,
                            pointStyle: 'triangle'
                        });
                    });
                }
            } else {
                // Single dataset mode - include filename in labels
                const filenameShort = getFilenameWithoutExtension(primaryFilename) || 'data';

                if (groupBy === 'none') {
                    let dataToPlot = [...filteredData];
                    dataToPlot = applyParetoFilter(dataToPlot, yMetric);
                    const sortedData = sortDataByXAxis(dataToPlot);

                    datasets = [{
                        label: filenameShort,
                        data: sortedData.map(row => ({
                            x: xAxis === 'mean_precisions' ? row[xAxis] * 100 : row[xAxis],
                            y: yMetric.includes('time') && yMetric !== 'total_upload_time' ? row[yMetric] * 1000 : row[yMetric],
                            originalData: row
                        })),
                        borderColor: colors[0],
                        backgroundColor: colors[0] + '80',
                        borderWidth: chartType === 'line' ? 3 : 1,
                        fill: false,
                        tension: 0.4,
                        pointRadius: chartType === 'scatter' ? 6 : 4
                    }];
                } else {
                    const groups = [...new Set(filteredData.map(d => d[groupBy]))];
                    datasets = groups.map((group, index) => {
                        let groupData = filteredData.filter(d => d[groupBy] === group);
                        groupData = applyParetoFilter(groupData, yMetric);
                        groupData = sortDataByXAxis(groupData);

                        return {
                            label: `${filenameShort}: ${group}`,
                            data: groupData.map(row => ({
                                x: xAxis === 'mean_precisions' ? row[xAxis] * 100 : row[xAxis],
                                y: yMetric.includes('time') && yMetric !== 'total_upload_time' ? row[yMetric] * 1000 : row[yMetric],
                                originalData: row
                            })),
                            borderColor: colors[index % colors.length],
                            backgroundColor: colors[index % colors.length] + '80',
                            borderWidth: chartType === 'line' ? 3 : 1,
                            fill: false,
                            tension: 0.4,
                            pointRadius: chartType === 'scatter' ? 6 : 4
                        };
                    });
                }
            }

            const isTimeMetric = yMetric.includes('time');
            const yLabel = yMetric === 'total_upload_time' ? 'Index Time (s)' :
                          isTimeMetric ? yMetric.replace('_', ' ').toUpperCase() + ' (ms)' :
                          yMetric.replace('_', ' ').toUpperCase();

            const xLabel = xAxis === 'mean_precisions' ? 'Precision (%)' :
                          xAxis.replace('_', ' ').toUpperCase();

            return {
                type: chartType === 'scatter' ? 'scatter' : chartType,
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                threshold: 10
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    speed: 0.1
                                },
                                pinch: {
                                    enabled: true
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    borderColor: 'rgba(59, 130, 246, 0.5)',
                                    borderWidth: 1
                                },
                                mode: 'xy'
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(tooltipItems) {
                                    const item = tooltipItems[0];
                                    const originalData = item.raw.originalData;
                                    return originalData.setup_name || 'Unknown Setup';
                                },
                                label: function(context) {
                                    const originalData = context.raw.originalData;
                                    const yUnit = yMetric === 'total_upload_time' ? 's' :
                                                 yMetric.includes('time') ? 'ms' :
                                                 (yMetric === 'rps' ? 'RPS' : '');
                                    const xUnit = xAxis === 'mean_precisions' ? '%' : '';

                                    let labels = [];
                                    labels.push(`${xLabel}: ${context.parsed.x}${xUnit}`);
                                    labels.push(`${yLabel}: ${context.parsed.y.toFixed(2)}${yUnit}`);

                                    // Add parallel threads info
                                    if (originalData.parallel !== undefined) {
                                        labels.push(`Parallel: ${originalData.parallel} threads`);
                                    }

                                    if (originalData.engine_params && originalData.engine_params.hnsw_config) {
                                        const hnsw = originalData.engine_params.hnsw_config;
                                        labels.push(`HNSW Config:`);
                                        if (hnsw.m) labels.push(`  ‚Ä¢ m: ${hnsw.m}`);
                                        if (hnsw.ef_construct) labels.push(`  ‚Ä¢ ef_construct: ${hnsw.ef_construct}`);
                                        if (hnsw.ef) labels.push(`  ‚Ä¢ ef: ${hnsw.ef}`);
                                        if (originalData.engine_params.hnsw_ef) labels.push(`  ‚Ä¢ hnsw_ef: ${originalData.engine_params.hnsw_ef}`);
                                    }

                                    return labels;
                                },
                                footer: function(tooltipItems) {
                                    const item = tooltipItems[0];
                                    const originalData = item.raw.originalData;
                                    let footerLines = [];

                                    if (originalData.engine_name) {
                                        footerLines.push(`Engine: ${originalData.engine_name}`);
                                    }
                                    if (originalData.dataset_name) {
                                        footerLines.push(`Dataset: ${originalData.dataset_name}`);
                                    }

                                    // Show file source and filename in comparison mode
                                    if (isComparisonMode && comparisonData.length > 0) {
                                        const sourceFilename = originalData.fileSource === 'primary' ?
                                            getFilenameWithoutExtension(primaryFilename) :
                                            getFilenameWithoutExtension(comparisonFilename);
                                        footerLines.push(`Source: ${sourceFilename}`);
                                    }

                                    // Always show filename if available
                                    if (originalData.filename) {
                                        footerLines.push(`File: ${originalData.filename}`);
                                    }

                                    return footerLines;
                                }
                            },
                            displayColors: false,
                            titleAlign: 'center',
                            bodyAlign: 'left',
                            footerAlign: 'center',
                            titleFont: { weight: 'bold', size: 14 },
                            bodyFont: { size: 12 },
                            footerFont: { size: 10, style: 'italic' },
                            padding: 12,
                            cornerRadius: 8,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            footerColor: '#ccc'
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: xLabel },
                            grid: { color: '#E5E7EB' },
                            type: xAxis === 'setup_name' ? 'category' : 'linear'
                        },
                        y: {
                            title: { display: true, text: yLabel },
                            grid: { color: '#E5E7EB' }
                        }
                    }
                }
            };
        }

        function updateChart() {
            const yMetric = yMetricSelect.value;
            const xAxis = xAxisSelect.value;

            const yMetricDisplay = yMetric === 'total_upload_time' ? 'Index Time' :
                                  yMetric.replace('_', ' ').toUpperCase();
            chartTitle.textContent = `${yMetricDisplay} vs ${xAxis.replace('_', ' ').toUpperCase()}`;

            // Update summary labels to show filenames without extension
            const primarySummaryLabel = document.getElementById('primarySummaryLabel');
            const comparisonSummaryLabel = document.getElementById('comparisonSummaryLabel');
            if (primarySummaryLabel) {
                primarySummaryLabel.textContent = getFilenameWithoutExtension(primaryFilename) || 'Primary';
            }
            if (comparisonSummaryLabel) {
                comparisonSummaryLabel.textContent = getFilenameWithoutExtension(comparisonFilename) || 'Comparison';
            }

            if (chart) {
                chart.destroy();
            }

            if (filteredData.length > 0) {
                const ctx = document.getElementById('benchmarkChart').getContext('2d');
                chart = new Chart(ctx, getChartConfig());
            }
        }
    </script>
</body>
</html>